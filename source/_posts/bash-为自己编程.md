---
title: 'bash:为自己编程 --unixer极简生存手册'
date: 2021-01-14 11:56:04
tags:
---
## 无处不在的"文件"
unix中一切皆文件。
```shell
pwd 查看当前目录
ls  查看当前目录下的文件
cd  进入指定目录

/ 根目录
. 当前目录简写
.. 上级目录简写

mkdir 创建目录
touch 创建文件
ln 创建文件链接,"-s"可以创建目录链接
rm 删除目录或文件 
mv 移动目录或文件
cp 复制目录或文件

tree 查看目录内的结构,"-L 2"控制查看深度
du 查看目录下的各文件目录磁盘占用,"-d1"控制查看深度

cat 查看文件内的文本内容
head 仅看文件开头内容
tail 仅看文件结尾内容,"-F"实时展示最新的尾部内容
less 分页输出文件内容

find 搜索目录或文件
grep 搜索文件内容
which 查看命令的位置,命令是执行文件,本质也是文件

vim 编辑文件内容
wc 统计文件的文本数据
```

## "输入"、"输出"和"管道"
在shell命令行中首先输入的单词全部被当成"命令"来处理,后面的单词被该"命令"内的"$*"获取。  
如果该"命令"有交互逻辑,"命令"内的"read"会获取输入的数据。  
"命令"会将产生的数据传给shell,shell通过"标准输出"展示到屏幕上。  
如果"命令B"想接着处理"命令A"输出的数据,可以用管道来实现 "A|B"。  
"命令B"能成功接收数据的前提是因为有交互逻辑，除此以外也可以借助xargs命令来实现。  

shell会识别命令后的 "<"  字符(通常之后还有一个文件名),将文本中的内容当做和命令交互的"标准输入",只需要命令支持交互。
shell会识别命令后的 "<<" 字符(通常之后还有HereDoc),将HereDoc的内容当做和命令交互的"标准输入",只需要命令支持交互。
shell会识别命令后的 ">"  字符(通常之后还有一个文件名),将原本输出到屏幕上的数据重定向到文本中(覆盖文本)。
shell会识别命令后的 ">>" 字符(通常之后还有一个文件名),将原本输出到屏幕上的数据重定向到文本中(追加文本)。

大致原型:
"命令A"
"命令A" < "文本A"
"命令A" > "文本C"
"命令A" < "文本A" > "文本C"
"命令A" | "命令C"
"命令A" | "命令C" > "文本C"
"命令A" < "文件A" | "命令B" | "tee" "文件B" | "命令C" > "文件C"

注意: 不存在 "命令A" < "文本A" > "命令C",因为命令必须在第一位。即 "文件A" > "命令A" 是非法格式。

测试shell
```shell
#!/usr/bin/env bash

# shell脚本 a.sh
echo "args: ",$*
while read str;do
  echo "stdin: ",$str
done

```
输出结果
```
./a.sh 111 <<EOF
heredoc> 222
heredoc> 333
heredoc> EOF
args: ,111
stdin: ,222
stdin: ,333

cat test.txt
One
twO
three

./a.sh 111 < test.txt
args: ,111
stdin: ,One
stdin: ,twO
stdin: ,three
```

## Shell语法
### 字符

### 数组
### 判断
### 循环

## 文字处理工具
### grep 全文查找   
### sed 流编辑，行处理  
### awk 全面的文本处理  

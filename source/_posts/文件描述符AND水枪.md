---
title: 文件描述符AND水枪
date: 2021-01-27 16:58:40
tags: [linux,bash]
---

Shell`辅助`我们调用其他命令。我们要时时刻刻记住，是Shell启动了`命令`，`命令`被启动时看到的`环境`是被Shell修改了的。  
比如：  
```shell
cat *.log  
```
`命令cat`会输出工作目录下所有".log"结尾的文件内容，因为Shell启动`命令cat`前时把 "*.log"替换了。  

那么我们写`文件重定向`时Shell做了什么呢？  
首先我们看看重定向的写法:  
```shell
cmd0 0< list.txt     # 标准输入  
cmd0 < list.txt      # 标准输入(简写)  

cmd1 1> data.log     # 标准输出  
cmd1 > data.log      # 标准输出(简写)  

cmd2 2> err.log      # 标准错误输出(其他文件描述符不能简写)   
```

Shell会扫描到 `0<`, `<`, `1>`, `>`, `2>` 等带有`<`,`>`的字符串，开始设置`文件描述符`的`重定向`，然后启动`命令cmd`。  
`命令cmd`以正常的方式工作，如果用到了被Shell重定向的`文件描述符`，他也不会察觉到。   

`标准输入0`是单向，向内的。数据传输到命令cmd0自身。  
`标准输出1`和`标准错误2`是单向，向外的。   
其他文件描述符都是双向的。   

`cmd0` 如果用到了`标准输入`，它等来的不是`键盘`输入的数据，而是`文件`传入的数据。  
`cmd1` 如果用到了`标准输出`，它以为把数据输出到`屏幕`上，其实去了`文件`中。  

把`文件描述符`当成`水枪`。    
把左边的`命令cmd`和右边的`文件file`当成水池。   

文件描述符是进程私有的，它指向的`文件`其实是`套接字`，  
真实情况是只有`操作系统`能打开文件，操作系统掌握着`套接字`，所以`套接字`是共有的。  

所以`文件描述符`可以随时修改指向的`套接字`。   
例如 `2>&1`，即是将`2号文件描述符`重新指向`1号文件描述符`当时指向的`套接字`。   
可以比喻成 `2号水枪`也去`1号水枪`放水的`池子`里放水了。

```shell
cmd file1   # file1被cmd打开，默认给它一个新的文件描述符，012已经被占用了，所以会有文件描述符3表示打开的file1。   
cmd < file2 # file2被Shell重定向到0，即用0来表示打开的file2。而cmd在等待标准输入0的输入数据。

cmd >file3 2>&   # 1号文件描述符指向file3，2号文件描述符跟着也指向1号文件描述符指向的file3。
# 故1号2号文件描述符都指向了同一个文件。  
cmd 2>& >file4   #2号文件描述符跟着1号文件描述符指向的文件，而1号描述符转而指向file4。
# 故1号2号文件描述符分别指向了两个文件。
```

[其他补充](https://www.junmajinlong.com/shell/fd_duplicate/)

---
title: 文件描述符AND水枪
date: 2021-01-27 16:58:40
tags:
---

Shell 类似宏语言。它辅助我们调用其他命令。我们要时时刻刻记住，是Shell在启动执行命令，命令启动时看到的环境是被Shell修改了的。  
比如：  
cat *.log  
cat会输出工作目录下所有".log"结尾的文件内容，因为Shell启动命令时把 "*.log"替换了。  

那么我们写文件重定向时它做了什么呢？  
首先我们看看重定向的写法:  

cmd0 0< list.txt     # 标准输入  
cmd0 < list.txt      # 标准输入(简写)  

cmd1 1> data.log     # 标准输出  
cmd1 > data.log      # 标准输出(简写)  

cmd2 2> err.log      # 标准错误输出(其他文件描述符不能简写)   

Shell会扫描到 "0<", "<", "1>", ">", "2>" 等带有"<",">"的字符串，开始设置文件描述符的重定向，然后启动命令。  
命令以正常的方式工作，如果用到了被Shell重定向的文件描述符，他也不会察觉到。   

标准输入0是单向，向内的。数据传输到命令cmd0自身。  
标准输出1和标准错误2是单向，向外的。   
其他文件描述符都是双向的。   

cmd0 如果用到了标准输入，它等来的不是键盘输入的数据，而是文件传入的数据。  
cmd1 如果用到了标准输出，它以为把数据输出到屏幕上，其实去了文件中。  

把文件描述符当成水枪。    
把左边的命令和右边的"文件"当成水池。   

文件描述符是进程私有的，它指向的"文件"其实是"套接字"，  
真实情况是只有操作系统能打开文件，操作系统掌握着"套接字"，所以"套接字"是共有的。  

所以文件描述符可以随时修改指向的套接字。   
例如 2>&1，即是将2号文件描述符重新指向1号文件描述符当时指向的套接字。   
可以比喻成 2号水枪去1号水枪放水的池子里放水了。

cmd file1   
cmd < file2   
file1被cmd打开，默认给它一个新的文件描述符，012已经被占用了，所以会有文件描述符3表示打开的file1。   
file2被Shell重定向到0，即用0来表示打开的file2。而cmd在等待标准输入0的输入数据。

cmd >file3 2>&   
1号文件描述符指向file3，2号文件描述符跟着也指向1号文件描述符指向的file3。故1号2号文件描述符都指向了同一个文件。  
cmd 2>& >file4   
2号文件描述符跟着1号文件描述符指向的文件，而1号描述符转而指向file4，故1号2号文件描述符分别指向了两个文件。


https://www.junmajinlong.com/shell/fd_duplicate/

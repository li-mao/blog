---
title: 为了封装变化
date: 2021-03-01 17:50:03
tags:
---
### 初级抽象

当我们开始用`面向对象`的方式去`重构`一段`面向过程`的代码时

最开始：   
`重构`成`一个类`，`公共变量`成为`私有属性`，`公共方法`控制`主逻辑`（`主方法`），`私有方法`封装`变化`（`助手方法`）。   

执行的时候，用`这个类`实例化一个`对象`，然后执行这个对象的`主方法`。  

当`助手方法`越来越独立：   
比如，它在调用自己的`助手方法`，这一套方法有自己的`公共属性`时，就需要把这一套方法和属性分出来成为`新类`。   
最开始的类是`客户类`，新分出来的是`服务类`。  
当`客户类`需要多个服务时，就会有多个`服务类`。  

执行的时候，用`客户类`实例化一个`客户对象`，传入它需要的`服务类`的对象，然后执行这个`客户对象`的`主方法`。

`服务类`应对变化：   
如果`需求`变化了，最好是仅修改`服务类`对象。   

执行的时候，用客户类实例化一个`客户对象`，传入`新服务类`对象，而`新服务类`包含了绝大部分的变化。  

`客户类`应对变化：  
`客户类`应该提前把需要的`服务类`抽象成通用的父类，比如`抽象类`、`接口interface`，这样在接收`新对象`时就不用修改`类型限制`。  
这些`类型限制`的目的是想保证新对象的`方法`不变，其实`类型限制`最好改成`接口interface`。  

执行的时候，用客户类实例化一个客户对象，传入实现了同样`接口interface`的`新服务类`对象，然后执行这个`客户对象`的`主方法`。  


总结：  
只需要一个类 ---> 客户类 需要 服务类 ---> 客户类 需要 实现同样接口的服务类

### 结构型模式

1.代理模式：（用旧方法名复用旧方法，外部）
`客户类`原先调用的`实现了某interface的服务类`对象的方法，需要在该方法前后增加一些处理工作。   
(这些新增的工作也可以在`客户类`内部做的，但这不符合`最小修改`，应该只修改是服务类)   
新写一个`实现了同样interface的服务类`做了这些新增的处理工作，而方法名不变，就把它当`第一服务类`。

2.装饰模式：（用旧方法名复用旧方法，内部）
和`代理模式`类似，是`客户类`内部 主动实例化`装饰对象`（实例化时传入`旧对象`），让它成为增强版的`旧对象`，后续调用`装饰对象`的`旧方法名`。
在`客户类`内部实例化是为了`按需选择`不同的装饰对象

3.适配器模式：（用新方法名复用旧方法）    
`客户类`需要`实现适配器interface的服务类`，这个类的方法适配了其他`已有的服务类`的方法，两者方法名不同。   
与`外观模式`比，`客户类`调用的方法不变。
 
4.外观模式：（用新方法名复用一堆旧方法逻辑）    
`一套复杂的子服务类`被`第一服务类`管理，`客户类`只需知道第一服务类可能解决这个需求就行了。   
通常是已经存在了`一套复杂的子服务类`，如何理清它们的关系太困难。就写一个`第一服务类`来简化`客户类`的调用。   
与`适配器模式`比，`客户类`调用新方法。

5.桥接模式：（一个多变的新对象）  
`组合优于继承`的经典例子
`实现了某interface的第二服务类`的各方法独立且多变，每种变化都写单独一个类的话，类的数量会爆炸，
写一套`包含单独方法的interface`，`第二服务类`的方法去引用这些单独实现的方法。
`第一服务类`生成了`实现了某interface的第二服务类`的对象，并返回给`客户类`，`客户类`直接操作`第二服务类`。  

6.组合模式：（一群同类对象，嵌套）
`实现了某interface的服务类`，可能有多个。   
有一个是`大哥A`，`大哥A`通过容器管理弟弟妹妹，弟弟妹妹里也可能有一个`大哥AA`，`大哥AA`通过容器也管理一批弟弟妹妹，可以如此循环。   
客户类需要`大哥A`。   

7.享元模式：（一群同类对象，少内存占用） 
由于系统中存在太多类似的`第一服务类`对象，就通过`内存共享`减少`第一服务类`对象的内存占用，   
这些`第一服务类`把内部通用的属性和方法移到某一个专门的单例`享元类`，有一个单例工厂，专门生产这些单例。
`客户类`只需知道调用`第一服务类`就行了。
`组合模式`就有很多类似的`服务类`，可用`享元模式`来减少内存占用。

### 行为型模式

1.责任链模式：  
和`组合模式`类似，但没有嵌套，且`大哥A`会把包含弟弟妹妹的容器交给`客户类`，让`客户类`自主控制执行。  

2.命令模式：
`组合优于继承`的另一个经典例子。
`客户类`往`实现了命令interface的第一服务类`A对象传入`实现了接收interface的第二服务类`B对象（可能多个`B对象`），
`A对象`会调用`B对象`的方法（控制调用过程，可能调用多个方法，`B对象`是真正的服务对象）。

3.迭代器模式：
`客户类`会调用`实现了某interface`的`容器服务类A`，并迭代该容器内的元素。
通常`容器服务器A`会自带可以迭代自身的`迭代服务类B`，这样的话`客户类`调用`A类对象`的迭代方法就够了。
`客户类`也可以指定`实现了某interface`的`迭代服务器B`给`容器服务类A`。

4.中介者模式：
`组件interface`和`中介interface`会双向调用。
有一个`中介实现类`，管理多个`组件实现类`。
`中介类`和`主件类`之间有耦合，`组件类`之间没有耦合。
`中介类`和`客户类`的沟通是双向的，和`组件类`沟通也是双向的。

5.备忘录模式
`客户类`调用`第一服务类`。
`第一服务类`会在每次属性发生变化时，把`要发生变化的属性`保存到新的`备忘类`对象，
并把该`备忘类`对象，传给`备忘容器类`对象保存（备忘类和备忘容器类 的关系 是`组合模式`里的哥哥管理弟弟妹妹）。
`备忘容器类`对象内部是按`栈`的方式保存传来的`对象`，方便`第一服务类`对象随时取回。

6.观察者模式：   
`客户类`调用`发布者类`对象。
`发布者类`内部有`消息通知interface`容器，会按`主题`分成几个容器。
实现了`消息通知interface`类的对象，会向`发布者类`对象注册想订阅的`主题`，
`发布者类`对象将这些`订阅者`保存到不同`主题`的容器内。
`发布者类`对象会把`客户类`对象传来的消息按不同的主题依次通知到各个`订阅者`。
当某个`订阅者`通过`客户类`对象传递同一`主题`的消息时，会有死循环风险。

7.状态模式：   
`上下文类`保存了`Status interface`的多个对象，并设置其中一个对象为内部的 当前 `Status类`对象变量，
这些`对象`可以通过`上下文类`对象的`change方法`，来改变`上下文类`对象内部的 当前 `Status类`对象变量。   
是的，这些 `Status类`对象 彼此都知道对方的存在。
`客户类`通过`上下文类`间接调用其中的当前`Status类`对象变量，  
`Status类`会通知`上下文类`要切换别的`Status类`，而`客户类`并不知道。   

8.策略模式：
和`状态模式`不同的是`客户类`会通过`上下文类`主动切换 当前`策略类对象`，
这些 `策略类`对象 并不知道彼此。

9.模板方法模式：
在普通的继承中，父类留出要重写的方法，保留 如何调用这些方法 的`主方法`，final。
子类接着重写这些方法，`客户类`调用子类对象的`主方法`。

10.访问者模式：
`实现了访问者interface`的类作为`访问者`，被`客户类`传入`数据表对象`的`欢迎访问方法`。
`继承某抽象类`的 `子类` 作为数据表，有`欢迎访问方法`接收`访问者`，并主动调用`访问者`的`操作数据方法`，来操作该`数据表`的数据。
（数据表对象 被动等待 访问者 ，再把 本对象 传给 访问者）
`客户类对象`遍历`数据表`容器，让每个`访问者`都去操作`数据表`的数据。
`数据表类`不应该频繁变动`属性`，因为每次变动，`访问者`也要跟着修改`操作方法`。





























---
title: 为了封装变化
date: 2021-03-01 17:50:03
tags:
---

当我们开始用`面向对象`的方式去`重构`一段`面向过程`的代码时

最开始：   
`重构`成`一个类`，`公共变量`成为`私有属性`，`公共方法`控制`主逻辑`（`主方法`），`私有方法`封装`变化`（`助手方法`）。   

执行的时候，用`这个类`实例化一个`对象`，然后执行这个对象的`主方法`。  

当`助手方法`越来越独立：   
比如，它在调用自己的`助手方法`，这一套方法有自己的`公共属性`时，就需要把这一套方法和属性分出来成为`新类`。   
最开始的类是`客户类`，新分出来的是`服务类`。  
当`客户类`需要多个服务时，就会有多个`服务类`。  

执行的时候，用`客户类`实例化一个`客户对象`，传入它需要的`服务类`的对象，然后执行这个`客户对象`的`主方法`。

`服务类`应对变化：   
如果`需求`变化了，最好是仅修改`服务类`对象。   

执行的时候，用客户类实例化一个`客户对象`，传入`新服务类`对象，而`新服务类`包含了绝大部分的变化。  

`客户类`应对变化：  
`客户类`应该提前把需要的`服务类`抽象成通用的父类，比如`抽象类`、`接口interface`，这样在接收`新对象`时就不用修改`类型限制`。  
这些`类型限制`的目的是想保证新对象的`方法`不变，其实`类型限制`最好改成`接口interface`。  

执行的时候，用客户类实例化一个客户对象，传入实现了同样`接口interface`的`新服务类`对象，然后执行这个`客户对象`的`主方法`。  


总结：  
只需要一个类 ---> 客户类 需要 服务类 ---> 客户类 需要 实现同样接口的服务类

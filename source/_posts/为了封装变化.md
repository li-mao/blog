---
title: 为了封装变化
date: 2021-03-01 17:50:03
tags:
---
当我们开始用`面向对象`的方式去`重构`一段`面向过程`的代码时

最开始：   
`重构`成`一个类`，`公共变量`成为`私有属性`，`公共方法`控制`主逻辑`（`主方法`），`私有方法`封装`变化`（`助手方法`）。   

执行的时候，用`这个类`实例化一个`对象`，然后执行这个对象的`主方法`。  

当`助手方法`越来越独立：   
比如，它在调用自己的`助手方法`，这一套方法有自己的`公共属性`时，就需要把这一套方法和属性分出来成为`新类`。   
最开始的类是`客户类`，新分出来的是`服务类`。  
当`客户类`需要多个服务时，就会有多个`服务类`。  

执行的时候，用`客户类`实例化一个`客户对象`，传入它需要的`服务类`的对象，然后执行这个`客户对象`的`主方法`。

`服务类`应对变化：   
如果`需求`变化了，最好是仅修改`服务类`对象。   

执行的时候，用客户类实例化一个`客户对象`，传入`新服务类`对象，而`新服务类`包含了绝大部分的变化。  

`客户类`应对变化：  
`客户类`应该提前把需要的`服务类`抽象成通用的父类，比如`抽象类`、`接口interface`，这样在接收`新对象`时就不用修改`类型限制`。  
这些`类型限制`的目的是想保证新对象的`方法`不变，其实`类型限制`最好改成`接口interface`。  

执行的时候，用客户类实例化一个客户对象，传入实现了同样`接口interface`的`新服务类`对象，然后执行这个`客户对象`的`主方法`。  


总结：  
只需要一个类 ---> 客户类 需要 服务类 ---> 客户类 需要 实现同样接口的服务类



适配器模式：   
`客户类`需要`实现适配器interface的服务类`，这个类的方法适配了其他`已有的服务类`的方法，两者方法名不同。   
与`外观模式`比，`客户类`调用的方法不变。

外观模式：
`一套复杂的子服务类`被`第一服务类`管理，`客户类`只需知道第一服务类可能解决这个需求就行了。
通常是已经存在了`一套复杂的子服务类`，如何理清它们的关系太困难。就写一个`第一服务类`来简化`客户类`的调用。   
与`适配器模式`比，`客户类`调用新方法。

桥接模式：  
`第一服务类`存储了`实现了某interface的多种第二服务类`，方便`客户类`挑选合适的`第二服务类`对象。   
`客户类`知道`第一服务类`和`第二服务类`，通过`第一服务类`得到需要的`第二服务类`，并直接操作`第二服务类`。  

组合模式：
`实现了某interface的服务类`，可能有多个。
有一个是`大哥A`，`大哥A`通过容器管理弟弟妹妹，弟弟妹妹里也可能有一个`大哥Z`，`大哥Z`通过容器也管理一批弟弟妹妹，可以如此循环。
客户类需要`大哥A`。   

装饰模式：
和组合模式类似。 但没有嵌套，`大哥A`会依次执行后面的弟弟妹妹。

享元模式
由于系统中存在太多类似的`第一服务类`对象，就通过`内存共享`减少`第一服务类`对象的内存占用，   
这些`第一服务类`把内部通用的属性和方法移到某一个专门的单例`享元类`，有一个单例工厂，专门生产这些单例。
`客户类`只需知道调用`第一服务类`就行了。
`组合模式`就有很多类似的`服务类`，也可用`享元模式`来减少内存占用。

代理模式
`客户类`调用已有的`实现了某interface的服务类`对象的方法时，需要在该方法前后增加一些处理工作。
这些新增的工作也可以在`客户类`内部做的，
新写一个`实现了同样interface的服务类`做了这些新增的处理工作，而接口不变，就把它当`第一服务类`。




责任链模式
和装饰模式类似。但`大哥A`会把包含弟弟妹妹的容器交给`客户类`，让`客户类`自主控制执行。


